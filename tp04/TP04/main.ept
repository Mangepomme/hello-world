open Externc
open Types
open Fftc
open Sndio

const twiddle : Types.complex^1024

fun complex_add(i1:Types.complex;i2:Types.complex) returns (o:Types.complex)
let
    o = { re = i1.re +. i2.re; im = i1.im +. i2.im };
tel

fun complex_sub(i1:Types.complex;i2:Types.complex) returns (o:Types.complex)
let
    o = { re = i1.re -. i2.re; im = i1.im -. i2.im };
tel

fun complex_mul(i1:Types.complex;i2:Types.complex) returns (o:Types.complex)
let
    o = { re = i1.re *. i2.re -. i1.im *. i2.im; im = i1.re *. i2.im +. i1.im *. i2.re };
tel

fun complex_div_r(i1:Types.complex;i2:float) returns (o:Types.complex)
let
    o = { re = i1.re /. i2; im = i1.im /. i2 };
tel

fun complex_mul_r(i1:Types.complex;i2:float) returns (o:Types.complex)
let
    o = { re = i1.re *. i2; im = i1.re *. i2 };
tel


fun bf<<n:int>>(i1:Types.complex^n; i2:Types.complex^n)
                returns (o1:complex^n; o2:Types.complex^n)
var
    tmp : Types.complex^n;
let
    o1 = map<<n>> complex_add(i1, i2);
    tmp = map<<n>> complex_sub(i1, i2);
    o2 = o1;
tel

fun fft_aux2(i:Types.complex^2) returns (out:Types.complex^2)
var
    tmp1, tmp2 : Types.complex^1;
    i1, i2 : Types.complex^1;
let
    i1 = i[0..0];
    i2 = i[1..1];
    (tmp1, tmp2) = bf<<1>>(i1, i2);
    out = tmp1@tmp2;
tel

fun fft_aux4(i:Types.complex^4) returns (out:Types.complex^4)
var
    tmp1, tmp2 : Types.complex^2;
    res1, res2 : Types.complex^2;
let
    (tmp1, tmp2) = bf<<2>>(i[0..1], i[2..3]);
    res1 = fft_aux2(tmp1);
    res2 = fft_aux2(tmp2);
    out = res1@res2;
tel

fun fft_aux8(i:Types.complex^8) returns (out:Types.complex^8)
var
    tmp1, tmp2 : Types.complex^4;
    res1, res2 : Types.complex^4;
let
    (tmp1, tmp2) = bf<<4>>(i[0..3], i[4..7]);
    res1 = fft_aux4(tmp1);
    res2 = fft_aux4(tmp2);
    out = res1@res2;
tel

fun fft8(i:Types.complex^8) returns (out:Types.complex^8)
var
    tmp1 : Types.complex^8;
    tmp2 : Types.complex^8;
let
    tmp1 = fft_aux8(i);
    tmp2 = bitrev8(tmp1);
    out = map<<8>> complex_div_r (tmp2, [8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0]);
tel

fun fft_aux16(i:Types.complex^16) returns (out:Types.complex^16)
var
    tmp1, tmp2 : Types.complex^8;
    res1, res2 : Types.complex^8;
let
    (tmp1, tmp2) = bf<<8>>(i[0..7], i[8..15]);
    res1 = fft_aux8(tmp1);
    res2 = fft_aux8(tmp2);
    out = res1@res2;
tel

fun fft16(i:Types.complex^16) returns (out:Types.complex^16)
var
    tmp : Types.complex^16;
    tmp2 : Types.complex^16;
let
    tmp = fft_aux16(i);
    tmp2 = bitrev16(tmp);
    out = map<<16>> complex_div_r (tmp2, [16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0]);
tel

fun fft_aux32(i:Types.complex^32) returns (out:Types.complex^32)
var
    tmp1, tmp2 : Types.complex^16;
    res1, res2 : Types.complex^16;
let
    (tmp1, tmp2) = bf<<16>>(i[0..15], i[16..31]);
    res1 = fft_aux16(tmp1);
    res2 = fft_aux16(tmp2);
    out = res1@res2;
tel

fun fft32(i:Types.complex^32) returns (out:Types.complex^32)
var
    tmp : Types.complex^32;
    tmp2 : Types.complex^32;
let
    tmp = fft_aux32(i);
    tmp2 = bitrev32(tmp);
    out = map<<32>> complex_div_r (tmp2, (32.0^32));
tel

fun fft_aux64(i:Types.complex^64) returns (out:Types.complex^64)
var
    tmp1, tmp2 : Types.complex^32;
    res1, res2 : Types.complex^32;
let
    (tmp1, tmp2) = bf<<32>>(i[0..31], i[32..63]);
    res1 = fft_aux32(tmp1);
    res2 = fft_aux32(tmp2);
    out = res1@res2;
tel

fun fft64(i:Types.complex^64) returns (out:Types.complex^64)
var
    tmp : Types.complex^64;
    tmp2 : Types.complex^64;
let
    tmp = fft_aux64(i);
    tmp2 = bitrev64(tmp);
    out = map<<64>> complex_div_r (tmp2, (64.0^64));
tel


fun fft_aux128(i:Types.complex^128) returns (out:Types.complex^128)
var
    tmp1, tmp2 : Types.complex^64;
    res1, res2 : Types.complex^64;
let
    (tmp1, tmp2) = bf<<64>>(i[0..63], i[64..127]);
    res1 = fft_aux64(tmp1);
    res2 = fft_aux64(tmp2);
    out = res1@res2;
tel

fun fft128(i:Types.complex^128) returns (out:Types.complex^128)
var
    tmp : Types.complex^128;
    tmp2 : Types.complex^128;
let
    tmp = fft_aux128(i);
    tmp2 = bitrev128(tmp);
    out = map<<128>> complex_div_r (tmp2, (128.0^128));
tel


fun fft_aux256(i:Types.complex^256) returns (out:Types.complex^256)
var
    tmp1, tmp2 : Types.complex^128;
    res1, res2 : Types.complex^128;
let
    (tmp1, tmp2) = bf<<128>>(i[0..127], i[128..255]);
    res1 = fft_aux128(tmp1);
    res2 = fft_aux128(tmp2);
    out = res1@res2;
tel

fun fft256(i:Types.complex^256) returns (out:Types.complex^256)
var
    tmp : Types.complex^256;
    tmp2 : Types.complex^256;
let
    tmp = fft_aux256(i);
    tmp2 = bitrev256(tmp);
    out = map<<256>> complex_div_r (tmp2, (256.0^256));
tel


fun fft_aux512(i:Types.complex^512) returns (out:Types.complex^512)
var
    tmp1, tmp2 : Types.complex^256;
    res1, res2 : Types.complex^256;
let
    (tmp1, tmp2) = bf<<256>>(i[0..255], i[256..511]);
    res1 = fft_aux256(tmp1);
    res2 = fft_aux256(tmp2);
    out = res1@res2;
tel

fun fft512(i:Types.complex^512) returns (out:Types.complex^512)
var
    tmp : Types.complex^512;
    tmp2 : Types.complex^512;
let
    tmp = fft_aux512(i);
    tmp2 = bitrev512(tmp);
    out = map<<512>> complex_div_r (tmp2, (512.0^512));
tel


fun fft_aux1024(i:Types.complex^1024) returns (out:Types.complex^1024)
var
    tmp1, tmp2 : Types.complex^512;
    res1, res2 : Types.complex^512;
let
    (tmp1, tmp2) = bf<<512>>(i[0..511], i[512..1023]);
    res1 = fft_aux512(tmp1);
    res2 = fft_aux512(tmp2);
    out = res1@res2;
tel

fun fft1024(i:Types.complex^1024) returns (out:Types.complex^1024)
var
    tmp : Types.complex^1024;
    tmp2 : Types.complex^1024;
let
    tmp = fft_aux1024(i);
    tmp2 = bitrev1024(tmp);
    out = map<<1024>> complex_div_r (tmp2, (1024.0^1024));
tel



fun myread(size:int) returns (samples:float^256)
let
    samples = read_samples(size);
tel

fun mywrite(size:int;samples:float^256) returns ()
let
    () = write_samples(size, samples);
tel

(*
    Calcule les MIFs sur un cycle de 10 MIFs.
    Appelle le scheduling de fast, thermal et gnc.
    Sleep sur 1 secondes.
*)

fun div_2(dividor:float; samples: float) returns (a:float)
let
    a = samples /. dividor;
tel

(*
node main() returns ()
var samples:float^250; size:int; samples2:float^250; b:float^250;
let
    size = 256;
    samples = myread(size);
    b = (2.0^250); 
    samples2 = map<<250>> (/.) (samples, b);
    () = mywrite(size, samples2);
tel
*)

fun float2complex(number:float) returns (a:Types.complex)
let
    a = { re = number; im = 0.0 };
tel

fun complex2float(number:Types.complex) returns (a:float)
let
    a = number.re;
tel

fun invComplex(c:Types.complex) returns (a:Types.complex)
let
    a = { re = c.im; im = c.re };
tel


fun ifft1024(c:Types.complex^1024) returns (out:Types.complex^1024)
var
    inv: Types.complex^1024;
    rep: Types.complex^1024;
    a:   Types.complex^1024;
let
    inv = map<<1024>> invComplex (c);
    rep = fft_aux1024(inv);
    a = map<<1024>> invComplex(rep);
    out = map<<1024>> complex_mul_r (a, (1024.0^1024));
tel

node main() returns ()
var
    s0, s1, s2, s3, t, zero_256:float^256;
    s4:float^1024;
    c0, c1, c2: complex^1024;
    c3: complex^256;
    size:int;
let
    size = 256;
    zero_256 = (0.0^256);
    s0 = myread(size);
    s1 = zero_256 fby s0;
    s2 = zero_256 fby s1;
    s3 = zero_256 fby s2;
    s4 = s3@s2@s1@s0;
    c0 = map<<1024>> float2complex(s4);
    c1 = fft1024(c0);
    c2 = ifft1024(c1);
    c3 = c2[0..255];
    t = map<<256>> complex2float (c3);
    () = mywrite(size, t);
tel
